<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quadrado vs Inimigos + Power Up Estrela + Canh√£o</title>
    <style>
        body {
            background-color: #212121;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            background-color: #a2df06;
            border: 5px solid #0ff;
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
        }
    </style>
</head>
<body>
<canvas id="game" width="600" height="600"></canvas>

<script>
let timeStopCircleGrowing = false;
let lastFrame = performance.now();
let isTimeStopVisualActive = false;
let showTimeStopMessage = false;
let timeStopMessageTimer = 0;
let timeStopCircleSize = 0; // üî• ESSENCIAL!
let survivalTime = 0;
let score = 0;
let powerUpsCollected = 0;
let floatingTexts = [];
let zombieMode = false;
let zombieModeTimer = 0;
let zombieModeTriggered = false;

let gameState = "menu"; // menu | playing | gameover

const invencivelSound = new Audio("sons/NyanCatoriginal.mp3");
invencivelSound.volume = 0.5;
invencivelSound.loop = true;

function isZombieMode() {
    return zombieMode;
}

const menuMusic = new Audio("sons/menu.mp3");
menuMusic.loop = true;
menuMusic.volume = 0.4;

const killSound = new Audio("sons/ahh.mp3");
killSound.volume = 0.4;

//const bgMusic = new Audio("sons/bg.mp3");
//bgMusic.loop = true;
//bgMusic.volume = 0.2;

const timestopSound = new Audio("sons/zahando.mp3");
timestopSound.volume = 0.6;

const dashSound = new Audio("sons/dash.mp3");
dashSound.volume = 0.4;

const gameOverSound = new Audio("sons/lose.mp3");


const damageSound = new Audio('sons/minecraft-death-sound-effect.mp3');
damageSound.volume = 0.5;

const zombSound = new Audio("sons/zombies.mp3")

const shootSound = new Audio('sons/pew_pew-dknight556-1379997159.mp3');
shootSound.volume = 0.4;

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const arenaSize = 600;
const box = 30;
let hasTimeStop = false;
let isTimeStopped = false;
let timeStopDuration = 0;
let timeStopEffectTimer = 0;




// Jogador
const player = {
    x: arenaSize / 2 - box / 2,
    y: arenaSize / 2 - box / 2,
    size: box,
    speed: 3,
    baseSpeed: 3,
    dx: 0,
    dy: 0,
    color: "#00f",
    speedBoostTimer: 0,
    invincibleTimer: 0,
    cannonTimer: 0,
    dashCooldown: 0,
    dashDuration: 0,
    isDashing: false,

};

const enemies = [];
let enemySpeed = 2;
let slowEnemiesTimer = 0;
let lives = 7;
const powerUps = [];
const projectiles = [];

const keys = {};
document.addEventListener('keydown', (e) => keys[e.key] = true);
document.addEventListener('keyup', (e) => keys[e.key] = false);
document.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;

    if (e.code === "Space" && player.dashCooldown <= 0) {
        startDash();
    }
});

document.addEventListener('keyup', (e) => keys[e.key.toLowerCase()] = false);
// substitua por isto
document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'e') {
        if (hasTimeStop && !isTimeStopped) {
            timestopSound.currentTime = 0;
            timestopSound.play();
            isTimeStopped = true;
            timeStopDuration = 300; // 5s
            timeStopEffectTimer = 0;
            hasTimeStop = false; // consome o poder

            // === IN√çCIO DA ALTERA√á√ÉO: comece a crescer o c√≠rculo IMEDIATAMENTE ===
            timeStopCircleGrowing = true;
            timeStopCircleSize = 0; // come√ßa do zero (ou 10 se preferir)
            // ====================================================================
            timeStopCenterX = player.x + player.size/2;
timeStopCenterY = player.y + player.size/2;
timeStopCircleSize = 0;
timeStopCircleGrowing = true;
        }
    }
});


let mouseX = 0;
let mouseY = 0;
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
});
canvas.addEventListener("click", () => {
    if (gameState !== "playing") {
        startGame();
    }
});
canvas.addEventListener('mousedown', () => {
    if (player.cannonTimer > 0) shoot();
});

// Arco-√≠ris
const rainbowColors = ["red", "orange", "yellow", "lime", "cyan", "blue", "magenta"];
let rainbowIndex = 0;

function startDash() {
    dashSound.currentTime = 0;
dashSound.play();
    if (player.dx !== 0 || player.dy !== 0) {
        player.isDashing = true;
        player.dashDuration = 10;      // Dura√ß√£o curta (~0,16s)
        player.dashCooldown = 120;     // 4 segundos (60fps x 4)
    }
}


function movePlayer() {
    let dashSpeed = player.isDashing ? player.speed * 5 : player.speed;

    player.dy = 0;
    player.dx = 0;

    if (keys["w"] && player.y > 0) player.dy = -dashSpeed;
    if (keys["s"] && player.y < arenaSize - player.size) player.dy = dashSpeed;
    if (keys["a"] && player.x > 0) player.dx = -dashSpeed;
    if (keys["d"] && player.x < arenaSize - player.size) player.dx = dashSpeed;

    player.x += player.dx;
    player.y += player.dy;
}

function startGame() {
    resetGame();
    survivalTime = 0;
    score = 0;
    powerUpsCollected = 0;
    gameState = "playing";
    menuMusic.pause();
menuMusic.currentTime = 0;
}

function updateFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
        let t = floatingTexts[i];

        t.y += t.vy;
        t.alpha -= 0.02;

        if (t.alpha <= 0) {
            floatingTexts.splice(i, 1);
        }
    }
}
function drawFloatingTexts() {
    ctx.save();

    floatingTexts.forEach(t => {
        ctx.globalAlpha = t.alpha;
        ctx.fillStyle = "#FFD700";
        ctx.font = "bold 20px Arial";
        ctx.fillText(t.text, t.x, t.y);
    });

    ctx.restore();
}

function spawnEnemy() {
    
    if (zombieModeTimer > 0) return;
    const sides = ["top", "bottom", "left", "right"];
    const side = sides[Math.floor(Math.random() * sides.length)];

    let x, y;
    const doorStart = (arenaSize / 2) - (box * 1.5);

    if (side === "top") {
        x = doorStart + Math.floor(Math.random() * 3) * box;
        y = 0;
    } else if (side === "bottom") {
        x = doorStart + Math.floor(Math.random() * 3) * box;
        y = arenaSize - box;
    } else if (side === "left") {
        x = 0;
        y = doorStart + Math.floor(Math.random() * 3) * box;
    } else {
        x = arenaSize - box;
        y = doorStart + Math.floor(Math.random() * 3) * box;
    }

    let isZombie = zombieMode || Math.random() < 0.20;

    enemies.push({
        x,
        y,
        size: box,
        color: isZombie ? "#2ecc71" : "#f00",
        isZombie: isZombie
    });
}
function spawnPowerUp() {
    const random = Math.random();
    let type;
    if (random < 0.25) type = "life";              // 25% vida
    else if (random < 0.45) type = "speed";        // 20% velocidade
    else if (random < 0.80) type = "slow";         // 35% inimigos lentos
    else if (random < 0.95) type = "cannon";       // 15% canh√£o
    else type = "star";                            // 5% estrela

    const x = Math.floor(Math.random() * (arenaSize / box)) * box;
    const y = Math.floor(Math.random() * (arenaSize / box)) * box;

    powerUps.push({
        x, y, size: box, type,
        color: type === "life" ? "#0f0" :
               type === "speed" ? "#ff0" :
               type === "slow" ? "#0ff" :
               type === "star" ? "rainbow" :
               "#964B00",
        timer: 500
    });
}


function isColliding(a, b) {
    return (
        a.x < b.x + b.size &&
        a.x + a.size > b.x &&
        a.y < b.y + b.size &&
        a.y + a.size > b.y
    );
}

function moveEnemies() {
    if (isTimeStopped) return;

    enemies.forEach((enemy, index) => {

        let baseSpeed = slowEnemiesTimer > 0 ? enemySpeed * (1 / 1.5) : enemySpeed;
        const speed = enemy.isZombie ? baseSpeed * 1.3 : baseSpeed;

        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;

        if (Math.abs(dx) > Math.abs(dy)) {
            enemy.x += dx > 0 ? speed : -speed;
        } else {
            enemy.y += dy > 0 ? speed : -speed;
        }

        if (isColliding(enemy, player)) {
            if (player.invincibleTimer <= 0) {
                enemies.splice(index, 1);
                lives -= enemy.isZombie ? 2 : 1;
                damageSound.currentTime = 0;
damageSound.play();
            } else {
    enemies.splice(index, 1);

    const gain = enemy.isZombie ? 200 : 100;
    score += gain;

    floatingTexts.push({
        x: enemy.x,
        y: enemy.y,
        text: "+" + gain,
        alpha: 1,
        vy: -0.5
    });
    killSound.currentTime = 0;
    killSound.play();
}
        }
    });
}

function moveProjectiles() {
    projectiles.forEach((p, index) => {
        p.x += p.dx;
        p.y += p.dy;

        if (p.x < 0 || p.x > arenaSize || p.y < 0 || p.y > arenaSize) {
            projectiles.splice(index, 1);
        }

        enemies.forEach((enemy, eIndex) => {
            if (isColliding(p, enemy)) {
                enemies.splice(eIndex, 1);
                projectiles.splice(index, 1);
                
                killSound.currentTime = 0;
                killSound.play();
                const gain = enemy.isZombie ? 200 : 100;
                score += gain;

                floatingTexts.push({
                    x: enemy.x,
                    y: enemy.y,
                     text: "+" + gain,
                          alpha: 1,
                 vy: -0.5           
});

console.log("texto criado");
            }
        });
    });
}

function shoot() {
    const angle = Math.atan2(mouseY - (player.y + player.size / 2), mouseX - (player.x + player.size / 2));
    const speed = 7;
    const size = 10;
    const dx = Math.cos(angle) * speed;
    const dy = Math.sin(angle) * speed;

    projectiles.push({
        x: player.x + player.size / 2 - size / 2,
        y: player.y + player.size / 2 - size / 2,
        dx, dy, size, color: "#fff"
    });

    shootSound.currentTime = 0;
    shootSound.play();
}

function updatePowerUps() {
    powerUps.forEach((p, index) => {
        
        p.timer--;
        if (p.timer <= 0) powerUps.splice(index, 1);

        if (isColliding(p, player)) {
            powerUpsCollected++; 
            if (p.type === "life") {
    lives += zombieMode ? 2 : 1;
}
            if (p.type === "speed") {
    player.speed = player.baseSpeed * 2;
   player.speedBoostTimer = zombieMode ? 900 : 600;

    
  if (Math.random() < 0.25) { // 25% de chance
    hasTimeStop = true;
    showTimeStopMessage = true;
    timeStopMessageTimer = 180;
}
}

            if (p.type === "slow") slowEnemiesTimer = 600;
            if (p.type === "star") {
                player.invincibleTimer = 1250;
                player.speed = player.baseSpeed * 5;
                invencivelSound.play();
            }
            if (p.type === "cannon") {
               player.cannonTimer = zombieMode ? 1300 : 1000;
            }

            powerUps.splice(index, 1);
        }
    });
}

function updateTimers(delta) {

    if (timeStopCircleGrowing) {
        timeStopCircleSize += 400 * delta;
    }
    if (gameState === "playing") {
    survivalTime += delta;
    }
    
    
    if (lives <= 0) {
    lives = 0; // evita negativo
    gameState = "gameover";
}

    if (timeStopCircleSize > Math.max(canvas.width, canvas.height)) {
        timeStopCircleSize = 0;
        timeStopCircleGrowing = false;
    }   if (timeStopCircleSize > Math.max(canvas.width, canvas.height)) {
        timeStopCircleSize = 0;
        isTimeStopVisualActive = false;
    }

    if (player.speedBoostTimer > 0) {
        player.speedBoostTimer--;
        if (player.speedBoostTimer === 0 && player.invincibleTimer <= 0) {
            player.speed = player.baseSpeed;
        }
    }
    if (player.invincibleTimer > 0) {
        player.invincibleTimer--;
        if (player.invincibleTimer === 0) {
            player.speed = player.baseSpeed;
            invencivelSound.pause();
            invencivelSound.currentTime = 0;
        }
    }
    if (player.cannonTimer > 0) {
        player.cannonTimer--;
    }
    if (slowEnemiesTimer > 0) {
        slowEnemiesTimer--;
    }
    if (player.dashCooldown > 0) player.dashCooldown--;
if (player.dashDuration > 0) {
    player.dashDuration--;
    if (player.dashDuration === 0) {
        player.isDashing = false;
    }
}

if (showTimeStopMessage) {
    timeStopMessageTimer--;
    if (timeStopMessageTimer <= 0) {
        showTimeStopMessage = false;
    }
}
if (isTimeStopped) {
    timeStopDuration--;
    timeStopEffectTimer++;

    if (timeStopDuration <= 0) {
    isTimeStopped = false;
    timeStopCircleSize = 0;
    timeStopCircleGrowing = true;
}

}

  if (isTimeStopped) {
        timeStopDuration--;
        timeStopEffectTimer++;

        if (timeStopDuration <= 0) {
            // encerra o timestop ‚Äî N√ÉO reiniciar ou resetar o circle aqui,
            // porque ele j√° est√° crescendo desde a ativa√ß√£o
            isTimeStopped = false;
            // n√£o fa√ßa: timeStopCircleGrowing = true; timeStopCircleSize = 10;
        }
    }
    if (score >= 4500 && !zombieModeTriggered) {
    zombieModeTriggered = true;
    enemies.length = 0;
    zombieModeTimer = 8; // segundos
}

if (zombieModeTimer > 0) {
    zombieModeTimer -= delta;
    if (zombieModeTimer <= 0) {
        zombieMode = true;
    }
}

}

function resetGame() {
    player.x = arenaSize / 2 - box / 2;
    player.y = arenaSize / 2 - box / 2;
    enemies.length = 0;
    powerUps.length = 0;
    projectiles.length = 0;
    lives = 5;
    player.speed = player.baseSpeed;
    player.speedBoostTimer = 0;
    player.invincibleTimer = 0;
    player.cannonTimer = 0;
    slowEnemiesTimer = 0;
}

function drawTimeStopCircle() {
    if (timeStopCircleGrowing) {
        ctx.beginPath();
        ctx.arc(
            timeStopCenterX + player.size / 2,
           timeStopCenterY + player.size / 2,
            timeStopCircleSize,
            0,
            Math.PI * 2
        );
        ctx.lineWidth = 5;
        ctx.strokeStyle = "rgba(255, 255, 0, 0.9)";
        ctx.stroke();
    }
}


const img = new (Image)
img.src = "imagens/arena.png"

function draw() {
    

    

      drawTimeStopCircle();
    

  if (gameState === "menu") {
   
        menuMusic.play();
    
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "#fff";

    ctx.font = "36px Arial";
    ctx.fillText("Sobreviva aos quadrados", 110, 150);

    ctx.font = "18px Arial";
    ctx.fillText("Tutorial:", 180, 200);
    ctx.fillText("AWDS ‚Äî mover", 160, 230);
    ctx.fillText("Space ‚Äî dash", 160, 255);
    ctx.fillText("Click ‚Äî tiro (power up marrom)", 100, 280);

    ctx.fillText("Matando os quadrados voc√™ ganha score.", 60, 330);
    ctx.fillText("Clique para come√ßar e divirta-se :3", 90, 360);

    return;
}
    
if (gameState === "gameover") {
    gameOverSound.play();
    ctx.fillStyle = "#000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "#f44";
    ctx.font = "50px Arial";
    ctx.fillText("GAME OVER", 170, 150);

    ctx.fillStyle = "#fff";
    ctx.font = "20px Arial";

    ctx.fillText("Tempo: " + survivalTime.toFixed(1) + "s", 220, 250);
    ctx.fillText("Score: " + score, 220, 280);
    ctx.fillText("Power Ups Coletados: " + powerUpsCollected, 220, 310);

    ctx.fillText("Clique para jogar novamente", 170, 380);

    return;
}

    //ctx.fillStyle = "#222";
    //ctx.fillRect(0, 0, arenaSize, arenaSize);

    const doorStart = (arenaSize / 2) - (box * 1.5);

    ctx.drawImage(img,0,0,arenaSize, arenaSize)
    ctx.fillStyle = "#555";
    ctx.fillRect(doorStart, 0, box * 3, box);
    ctx.fillRect(doorStart, arenaSize - box, box * 3, box);
    ctx.fillRect(0, doorStart, box, box * 3);
    ctx.fillRect(arenaSize - box, doorStart, box, box * 3);
    


    // Jogador
    if (player.cannonTimer > 0) {
        const angle = Math.atan2(mouseY - (player.y + player.size / 2), mouseX - (player.x + player.size / 2));
        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(player.x + player.size / 2, player.y + player.size / 2, player.size / 2, 0, Math.PI * 2);
        ctx.fill();
        // Canh√£o
        ctx.save();
        ctx.translate(player.x + player.size / 2, player.y + player.size / 2);
        ctx.rotate(angle);
        ctx.fillStyle = "#964B00";
        ctx.fillRect(0, -5, 25, 10);
        ctx.restore();
    } else {
        ctx.fillStyle = player.invincibleTimer > 0 ? rainbowColors[rainbowIndex] : player.color;
        ctx.fillRect(player.x, player.y, player.size, player.size);
    }

    // Inimigos
    enemies.forEach(enemy => {
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.size, enemy.size);
    });

    // Projet√©is
    projectiles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });

    // Power-ups
    powerUps.forEach(p => {
        ctx.fillStyle = p.type === "star" ? rainbowColors[rainbowIndex] : p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    });

    // HUD

    // === HUD extra ===
ctx.fillStyle = "#fff";
ctx.font = "16px Arial";

ctx.fillText("Tempo: " + survivalTime.toFixed(1) + "s", 10, 20);
ctx.fillText("Score: " + score, 10, 40);
ctx.fillText("PowerUps: " + powerUpsCollected, 10, 60);

    ctx.fillStyle = "#fff";
    ctx.font = "20px Arial";
    ctx.fillText("Vidas: " + lives, 10, 590);

    if (player.speedBoostTimer > 0) {
        ctx.fillStyle = "#ff0";
        ctx.fillText("Velocidade x2!", 120, 590);
    }

    if (showTimeStopMessage) {
    ctx.fillStyle = "#ff0";
    ctx.font = "20px Arial";
    ctx.fillText("Voc√™ obteve a Paralisa√ß√£o!", 180, 50);
}

    if (hasTimeStop) {
    ctx.fillStyle = "#ff0";
    ctx.font = "20px Arial";
    ctx.fillText("Paralisa√ß√£o (E)", 230, 70);
    }


    if (slowEnemiesTimer > 0) {
        ctx.fillStyle = "#0ff";
        ctx.fillText("Inimigos Lentos!", 300, 590);
    }

    if (player.invincibleTimer > 0) {
        ctx.fillStyle = "#f0f";
        ctx.fillText("INVENC√çVEL!", 480, 590);
    }

    if (player.cannonTimer > 0) {
        ctx.fillStyle = "#964B00";
        ctx.fillText("CANH√ÉO ATIVO!", 420, 30);
    }
    // === mensagem da horda ===
if (zombieModeTimer > 0 && gameState === "playing") {
    ctx.fillStyle = "#0f0";
    ctx.font = "bold 30px Arial";
    ctx.fillText("THE ZOMBIES ARE COMING", 80, 100);
    zombSound.play();
}

    drawTimeStopCircle();
         updateFloatingTexts();
drawFloatingTexts();
}

function gameLoop() {
    let now = performance.now();
    let delta = (now - lastFrame) / 1000;
    lastFrame = now;

 if (gameState === "playing") {
       

    movePlayer();
    moveEnemies();
    moveProjectiles();
    updatePowerUps();
    updateTimers(delta);



}
    draw(); // draw() deve chamar drawTimeStopCircle() internamente
    rainbowIndex = (rainbowIndex + 1) % rainbowColors.length;
    requestAnimationFrame(gameLoop);
}

setInterval(spawnEnemy, 1000);
setInterval(spawnPowerUp, 5000);
gameLoop();
</script>
</body>
</html>
